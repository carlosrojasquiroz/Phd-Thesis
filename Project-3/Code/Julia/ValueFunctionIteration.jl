# ValueFunctionIteration.jl

function ValueFunctionIteration(p::Param, m::Dict{Symbol, Any})
#===================================================================================
This function executes the vfi algorithm
===================================================================================#  
    @unpack Np, Nb, distV, distVd, distQ, ϵ, β, λ, r  = p
    #--------------------------------------------------------------------------------------------------------------------
    # Initial matrices
    #--------------------------------------------------------------------------------------------------------------------
    V = zeros(Np, Nb)       # Government's value function
    Vr = zeros(Np, Nb)      # Repayment value
    Vd = zeros(Np)          # Default value 
    Δ = zeros(Np, Nb)       # Default policy
    Γ = zeros(Int, Np, Nb)  # Debt policy  
    aux = zeros(Np, Nb, Nb) # Auxiliar matrix
    iterv = 0               # Number of iterations
    #--------------------------------------------------------------------------------------------------------------------
    # Unpacking matrices
    #--------------------------------------------------------------------------------------------------------------------
    P = m[:P]     # Np x 1: oil prices
    P̂ = m[:P̂]     # Np x 1: oil prices
    B = m[:B]'    # 1 x Nb: debt 
    Π = m[:Π]     # Np x Np: transition matrix
    I₀= m[:I0]    # Scalar: zero position in debt grid
    Q = m[:Q]     # Np x Nb: debt price
    #--------------------------------------------------------------------------------------------------------------------
    # Value function iteration
    #--------------------------------------------------------------------------------------------------------------------
    while distV > ϵ || distVd > ϵ || distQ > ϵ
        Vcomp = copy(V)
        Vdcomp = copy(Vd)
        Qcomp = copy(Q)
        #--------------------------------------------------------------------------------------------------------------------
        # Initial tax rate
        #--------------------------------------------------------------------------------------------------------------------
        τoptD, τoptR = inittau(p, m, Q)
        #--------------------------------------------------------------------------------------------------------------------
        # Default value
        #--------------------------------------------------------------------------------------------------------------------
        Vd = utility(P̂, ϵ, ϵ, τoptD, ϵ, p) + β .* Π * (λ .* V[:,Int(I₀)] .+ (1 - λ) .* Vd)
        #--------------------------------------------------------------------------------------------------------------------
        # Repayment value
        #--------------------------------------------------------------------------------------------------------------------   
        for i3 in 1 : Nb
            aux[:, :, i3] = utility(P, B, B[1,i3], τoptR[:, :, i3], Q[:, i3], p) .+ β .* Π * V[:, i3]
        end
        Vr, Γ = findmax(aux, dims = 3)
        Vr = dropdims(Vr, dims=3)
        #--------------------------------------------------------------------------------------------------------------------
        # Government's value function
        #--------------------------------------------------------------------------------------------------------------------
        V = (Vd .> Vr) .* Vd .+ (Vd .<= Vr) .* Vr
        #--------------------------------------------------------------------------------------------------------------------
        # Default policy
        #--------------------------------------------------------------------------------------------------------------------
        Δ = (Vd .> Vr) .* 1.0
        #--------------------------------------------------------------------------------------------------------------------
        # Debt price
        #--------------------------------------------------------------------------------------------------------------------
        Q =  (1.0 .- Π * Δ) ./ (1.0 .+ r)
        #--------------------------------------------------------------------------------------------------------------------
        # Convergence checks
        #--------------------------------------------------------------------------------------------------------------------
        distV = maximum(abs.(V - Vcomp) ./ ((abs.(V) .+ abs.(Vcomp)) ./ 2 .+ 0.001))
        distQ = maximum(abs.(Q - Qcomp) ./ ((abs.(Q) .+ abs.(Qcomp)) ./ 2 .+ 0.001))
        distVd = maximum(abs.(Vd - Vdcomp) ./ ((abs.(Vd) .+ abs.(Vdcomp)) ./ 2 .+ 0.001))
        #--------------------------------------------------------------------------------------------------------------------
        # Iteration
        #--------------------------------------------------------------------------------------------------------------------
        iterv += 1
        println("Iteration number: $iterv")
        println("Distance indicators: $distV; $distVd; $distQ; ", mean(Δ))
    end
    #--------------------------------------------------------------------------------------------------------------------
    # Equilibrium objects
    #--------------------------------------------------------------------------------------------------------------------
    τopt = zeros(Np, Nb)
    gopt = zeros(Np, Nb)
    copt = zeros(Np, Nb)
    bopt = zeros(Np, Nb)
    for i1 in 1 : Np
        for i2 in 1 : Nb
            if Δ[i1, i2] == 1
                τopt[i1, i2] = tmaxval(P[i1], ϵ, ϵ, ϵ, p)
                copt[i1, i2] = consumption(P[i1], τopt[i1, i2], p)
                gopt[i1, i2] = spending(P[i1], ϵ, ϵ, τopt[i1, i2], ϵ, p)
                bopt[i1, i2] = 0.0
            else
                τopt[i1, i2] = tmaxval(P[i1], B[i2], B[Γ[i1, i2][3]], Q[i1, Γ[i1, i2][3]], p)
                copt[i1, i2] = consumption(P[i1], τopt[i1, i2], p)
                gopt[i1, i2] = spending(P[i1], B[i2], B[Γ[i1, i2][3]], τopt[i1, i2], Q[i1, Γ[i1, i2][3]], p)
                bopt[i1, i2] = B[Γ[i1, i2][3]]
            end
        end
    end
    fopt = firms(P, τopt, p)
    hmopt = fopt[:hm]
    mopt = fopt[:m]
    hcopt = fopt[:hc]
    @unpack zmss, zcss, α, ϑ, θ, kmss, kcss, δ  = p
    ymopt = zmss .* hmopt .^ α .* mopt .^ θ .* kmss .^ (1 - α - θ)
    ycopt = zcss .* hcopt .^ ϑ .* kcss .^ (1 - ϑ)
    gdpopt = copt .+ gopt .+ δ * (kmss + kcss) .+ P .* ycopt .- P .* mopt
    tbopt = ymopt .- copt .- gopt .- δ * (kmss + kcss) .+ P .* ycopt .- P .* mopt
    #--------------------------------------------------------------------------------------------------------------------
    # Output
    #--------------------------------------------------------------------------------------------------------------------
    return Dict(
        :V => V,
        :Vd => Vd,
        :Vr => Vr,
        :Γ => Γ,
        :Δ => Δ,
        :Q => Q,
        :τopt => τopt,
        :copt => copt,
        :gopt => gopt,
        :bopt => bopt,
        :hmopt => hmopt,
        :hcopt => hcopt,
        :mopt => mopt,
        :ymopt => ymopt,
        :ycopt => ycopt,
        :gdpopt => gdpopt,
        :tbopt => tbopt
    )
end